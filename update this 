For professional web application vulnerability testing, you should follow a structured methodology combining automated scanning with manual techniques. Here's a comprehensive approach based on industry standards.

ðŸ“‹ Core Testing Methodology (OWASP-Based)

Follow this phased approach for thorough coverage:

1. Information Gathering & Mapping

Â· Spidering/Crawling: Use Burp Suite, OWASP ZAP, or gospider to discover all application endpoints
Â· Technology Fingerprinting: wappalyzer, whatweb, or manual inspection of headers/cookies
Â· API Discovery: Look for /api/, /graphql, /swagger.json, OpenAPI specs
Â· JavaScript Analysis: Extract endpoints and secrets from client-side JS files

2. Configuration & Deployment Testing

Â· Check for default files (robots.txt, .env, .git/, backup.zip)
Â· Test HTTP methods (OPTIONS, TRACE), headers, and HTTP Strict Transport Security
Â· Verify error handling doesn't leak stack traces
Â· Check CORS misconfigurations and file upload protections

3. Identity & Authentication Testing

Â· Test for weak password policies and account enumeration
Â· Check session management flaws (non-rotating session IDs, insecure cookies)
Â· Test multi-factor authentication bypass
Â· Verify logout functionality actually invalidates sessions

4. Authorization Testing

Â· Vertical/horizontal privilege escalation
Â· IDOR (Insecure Direct Object Reference) testing
Â· Path traversal and file inclusion
Â· JWT tampering if applicable

5. Input Validation Testing

Â· SQL injection (traditional, blind, time-based)
Â· Cross-Site Scripting (XSS) - reflected, stored, DOM-based
Â· Command injection, SSRF, XXE
Â· Template injection (SSTI)

6. Client-Side Testing

Â· DOM-based vulnerabilities
Â· WebSocket security
Â· PostMessage security
Â· Client-side storage issues

ðŸ”§ Essential Tool Stack

Here's a categorized toolkit for comprehensive testing:

Category Primary Tools Purpose
Interception Proxy Burp Suite Professional, OWASP ZAP Traffic interception, manual testing
Automated Scanners Nuclei, Nikto, Arachni Vulnerability detection
Fuzzers ffuf, wfuzz, Burp Intruder Parameter/input discovery
API Testing Postman, SoapUI, Kiterunner API endpoint security
JS Analysis LinkFinder, JSFinder, Subjs Endpoint discovery in JS
Specialized SQLmap, XSStrike, SSRFmap Targeted exploit testing

ðŸŽ¯ Practical Testing Checklist

Use this actionable workflow for assessments:

Phase 1: Reconnaissance

```bash
# 1. Subdomain enumeration
subfinder -d target.com -silent -o subs.txt
amass enum -passive -d target.com -o amass_subs.txt

# 2. Live host discovery
httpx -l subs.txt -silent -title -status-code -tech-detect -o live_hosts.txt

# 3. Screenshots & page analysis
gowitness file -f live_hosts.txt --screenshot-path screenshots/
```

Phase 2: Automated Scanning

```bash
# 4. Nuclei templates (critical/high severity only)
nuclei -l live_hosts.txt -t ~/nuclei-templates/ -severity critical,high -o nuclei_results.txt

# 5. Nikto baseline scan
while read url; do nikto -h "$url" -Format txt -o nikto_$(echo $url | sed 's/[^a-zA-Z0-9]/_/g').txt; done < live_hosts.txt
```

Phase 3: Manual Testing Setup

1. Configure Burp Suite:
   Â· Set up scope for target domain
   Â· Install essential extensions (Logger++, Autorize, Turbo Intruder)
   Â· Configure browser proxy settings
2. Spider the application:
   Â· Use both passive and active spidering
   Â· Manually explore all application workflows

Phase 4: Critical Vulnerability Tests

Authentication Bypass:

```bash
# Test for default credentials
hydra -L users.txt -P passwords.txt target.com http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"
```

SQL Injection:

```bash
# Quick parameter testing with SQLmap
sqlmap -u "https://target.com/product?id=1" --batch --level=2 --risk=2
```

XSS Testing:

```bash
# Use dalfox for automated XSS detection
cat urls_with_params.txt | dalfox pipe
```

Phase 5: Business Logic Testing

This requires manual exploration:

Â· Test price manipulation in cart workflows
Â· Attempt to bypass workflow restrictions
Â· Test for race conditions in high-value actions
Â· Check if business limits can be exceeded

ðŸš€ Advanced Modern Web App Testing

Single Page Application (SPA) Security

SPAs (React, Vue, Angular) require specialized approaches:

1. Client-side routing analysis:
   Â· Check if auth is enforced client-side only
   Â· Test direct navigation to "protected" routes
2. API security testing:
   Â· Test GraphQL endpoints for introspection leaks
   Â· Check for excessive data exposure in REST responses
   Â· Test for batch operations (like GraphQL batching attacks)
3. State management testing:
   Â· Inspect Vuex/Redux stores for sensitive data
   Â· Test if state persists appropriately after logout

API-First Application Testing

```bash
# 1. Discover API endpoints
katana -u https://api.target.com -jc -kf -d 3 -o api_endpoints.txt

# 2. Test for common API vulnerabilities
nuclei -l api_endpoints.txt -t ~/nuclei-templates/api/
```

CI/CD Integration for Continuous Testing

```yaml
# Example GitHub Actions workflow
name: Web Security Scan
on: [push]
jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run Nuclei Scan
        uses: projectdiscovery/nuclei-action@main
        with:
          target: https://your-app.com
          templates: cves,exposures,misconfigurations
```

ðŸ“Š Reporting & Remediation

1. Prioritize findings by CVSS scores and business impact
2. Provide proof-of-concept for critical vulnerabilities
3. Include remediation guidance with code snippets
4. Track retesting to verify fixes

âš ï¸ Important Considerations

Â· Get proper authorization before testing
Â· Use a controlled environment for production-like testing
Â· Respect rate limits to avoid DoS
Â· Document all findings thoroughly for reproducibility

For modern JavaScript frameworks (React/Vue), would you like specific testing methodologies, or are you more interested in API security testing approaches?1. Information Gathering & Mapping
â€¢ Spidering/Crawling: Use Burp Suite, OWASP ZAP or
gospider to discover all application endpoints
â€¢ Technology Fingerprinting: wappalyzer, whatweb, or manua
inspection of headers/cookies
â€¢ API Discovery: Look for /api/, /graphgl, /swagger.json,
OpenAPI specs
â€¢ JavaScript Analvsis: Extract endpoints and secrets from
client-side JS files
2. Configuration & Deployment Testing
â€¢ Check for default files (robots.txt, .env, . git/, backup.zip
â€¢ Test HTTP methods (OPTIONS, TRACE), headers, and
HTTP Strict Transport Security
â€¢ Verify error handling doesn't leak stack traces
â€¢ Check CORS misconfigurations and file upload protections
3. Identitv & Authentication Testing
â€¢ Test for weak password policies and account enumeration
â€¢ Check session management flaws (non-rotating session
IDs, insecure cookies
â€¢ Test multi-factor authentication bypass
â€¢ Verifv logout functionality actuallv invalidates sessionsquery { author { posts { author { posts { ... } } } } }
